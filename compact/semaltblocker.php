<?php

namespace TrueBV;class Punycode{const BASE=36;const TMIN=1;const TMAX=26;const SKEW=38;const DAMP=700;const INITIAL_BIAS=72;const INITIAL_N=128;const PREFIX='xn--';const DELIMITER='-';protected static$encodeTable=array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9',);protected static$decodeTable=array('a'=>0,'b'=>1,'c'=>2,'d'=>3,'e'=>4,'f'=>5,'g'=>6,'h'=>7,'i'=>8,'j'=>9,'k'=>10,'l'=>11,'m'=>12,'n'=>13,'o'=>14,'p'=>15,'q'=>16,'r'=>17,'s'=>18,'t'=>19,'u'=>20,'v'=>21,'w'=>22,'x'=>23,'y'=>24,'z'=>25,'0'=>26,'1'=>27,'2'=>28,'3'=>29,'4'=>30,'5'=>31,'6'=>32,'7'=>33,'8'=>34,'9'=>35);protected$encoding;public function __construct($encoding='UTF-8'){$this->encoding=$encoding;}public function encode($input){$parts=explode('.',$input);foreach($parts as&$part){$part=$this->encodePart($part);}return implode('.',$parts);}protected function encodePart($input){$codePoints=$this->listCodePoints($input);$n=static::INITIAL_N;$bias=static::INITIAL_BIAS;$delta=0;$h=$b=count($codePoints['basic']);$output='';foreach($codePoints['basic'] as$code){$output.=$this->codePointToChar($code);}if($input===$output){return$output;}if($b>0){$output.=static::DELIMITER;}$codePoints['nonBasic']=array_unique($codePoints['nonBasic']);sort($codePoints['nonBasic']);$i=0;$length=mb_strlen($input,$this->encoding);while($h<$length){$m=$codePoints['nonBasic'][$i++];$delta=$delta+($m-$n)*($h+1);$n=$m;foreach($codePoints['all'] as$c){if($c<$n||$c<static::INITIAL_N){$delta++;}if($c===$n){$q=$delta;for($k=static::BASE;;$k+=static::BASE){$t=$this->calculateThreshold($k,$bias);if($q<$t){break;}$code=$t+(($q-$t)%(static::BASE-$t));$output.=static::$encodeTable[$code];$q=($q-$t)/(static::BASE-$t);}$output.=static::$encodeTable[$q];$bias=$this->adapt($delta,$h+1,($h===$b));$delta=0;$h++;}}$delta++;$n++;}return static::PREFIX.$output;}public function decode($input){$parts=explode('.',$input);foreach($parts as&$part){if(strpos($part,static::PREFIX)!==0){continue;}$part=substr($part,strlen(static::PREFIX));$part=$this->decodePart($part);}return implode('.',$parts);}protected function decodePart($input){$n=static::INITIAL_N;$i=0;$bias=static::INITIAL_BIAS;$output='';$pos=strrpos($input,static::DELIMITER);if($pos!==false){$output=substr($input,0,$pos++);}else{$pos=0;}$outputLength=strlen($output);$inputLength=strlen($input);while($pos<$inputLength){$oldi=$i;$w=1;for($k=static::BASE;;$k+=static::BASE){$digit=static::$decodeTable[$input[$pos++]];$i=$i+($digit*$w);$t=$this->calculateThreshold($k,$bias);if($digit<$t){break;}$w=$w*(static::BASE-$t);}$bias=$this->adapt($i-$oldi,++$outputLength,($oldi===0));$n=$n+(int)($i/$outputLength);$i=$i%($outputLength);$output=mb_substr($output,0,$i,$this->encoding).$this->codePointToChar($n).mb_substr($output,$i,$outputLength-1,$this->encoding);$i++;}return$output;}protected function calculateThreshold($k,$bias){if($k<=$bias+static::TMIN){return static::TMIN;}elseif($k>=$bias+static::TMAX){return static::TMAX;}return$k-$bias;}protected function adapt($delta,$numPoints,$firstTime){$delta=(int)(($firstTime)?$delta/static::DAMP:$delta/2);$delta+=(int)($delta/$numPoints);$k=0;while($delta>((static::BASE-static::TMIN)*static::TMAX)/2){$delta=(int)($delta/(static::BASE-static::TMIN));$k=$k+static::BASE;}$k=$k+(int)(((static::BASE-static::TMIN+1)*$delta)/($delta+static::SKEW));return$k;}protected function listCodePoints($input){$codePoints=array('all'=>array(),'basic'=>array(),'nonBasic'=>array(),);$length=mb_strlen($input,$this->encoding);for($i=0;$i<$length;$i++){$char=mb_substr($input,$i,1,$this->encoding);$code=$this->charToCodePoint($char);if($code<128){$codePoints['all'][]=$codePoints['basic'][]=$code;}else{$codePoints['all'][]=$codePoints['nonBasic'][]=$code;}}return$codePoints;}protected function charToCodePoint($char){$code=ord($char[0]);if($code<128){return$code;}elseif($code<224){return(($code-192)*64)+(ord($char[1])-128);}elseif($code<240){return(($code-224)*4096)+((ord($char[1])-128)*64)+(ord($char[2])-128);}else{return(($code-240)*262144)+((ord($char[1])-128)*4096)+((ord($char[2])-128)*64)+(ord($char[3])-128);}}protected function codePointToChar($code){if($code<=0x7F){return chr($code);}elseif($code<=0x7FF){return chr(($code >> 6)+192).chr(($code&63)+128);}elseif($code<=0xFFFF){return chr(($code >> 12)+224).chr((($code >> 6)&63)+128).chr(($code&63)+128);}else{return chr(($code >> 18)+240).chr((($code >> 12)&63)+128).chr((($code >> 6)&63)+128).chr(($code&63)+128);}}}namespace Nabble\SemaltBlocker;use TrueBV\Punycode;class Domainparser{private static$top_names='ac.cn,ac.jp,ac.uk,ad.jp,adm.br,adv.br,agr.br,ah.cn,am.br,arq.br,art.br,asn.au,ato.br,av.tr,bel.tr,bio.br,biz.tr,bj.cn,bmd.br,cim.br,cng.br,cnt.br,co.at,co.jp,co.uk,com.au,com.br,com.cn,com.eg,com.hk,com.mx,com.ru,com.tr,com.tw,conf.au,cq.cn,csiro.au,dr.tr,ecn.br,edu.au,edu.br,edu.tr,emu.id.au,eng.br,esp.br,etc.br,eti.br,eun.eg,far.br,fj.cn,fm.br,fnd.br,fot.br,fst.br,g12.br,gb.com,gb.net,gd.cn,gen.tr,ggf.br,gob.mx,gov.au,gov.br,gov.cn,gov.hk,gov.tr,gr.jp,gs.cn,gx.cn,gz.cn,ha.cn,hb.cn,he.cn,hi.cn,hk.cn,hl.cn,hn.cn,id.au,idv.tw,imb.br,ind.br,inf.br,info.au,info.tr,jl.cn,jor.br,js.cn,jx.cn,k12.tr,lel.br,ln.cn,ltd.uk,mat.br,me.uk,med.br,mil.br,mil.tr,mo.cn,mus.br,name.tr,ne.jp,net.au,net.br,net.cn,net.eg,net.hk,net.lu,net.mx,net.ru,net.tr,net.tw,net.uk,nm.cn,no.com,nom.br,not.br,ntr.br,nx.cn,odo.br,oop.br,or.at,or.jp,org.au,org.br,org.cn,org.hk,org.lu,org.ru,org.tr,org.tw,org.uk,plc.uk,pol.tr,pp.ru,ppg.br,pro.br,psc.br,psi.br,qh.cn,qsl.br,rec.br,sc.cn,sd.cn,se.com,se.net,sh.cn,slg.br,sn.cn,srv.br,sx.cn,tel.tr,tj.cn,tmp.br,trd.br,tur.br,tv.br,tw.cn,uk.com,uk.net,vet.br,wattle.id.au,web.tr,xj.cn,xz.cn,yn.cn,zj.cn,zlg.br,co.nr,co.nz,com.fr,';public static function getRootDomain($url){$parsed=self::parseUrl($url);if(isset($parsed['rootdomain'])&&!empty($parsed['rootdomain'])){$punycode=new Punycode();$rootDomain=$punycode->encode($parsed['rootdomain']);return filter_var('http://'.$rootDomain,FILTER_VALIDATE_URL)?strtolower($rootDomain):false;}return false;}private static function parseUrl($url){$element=array('url','scheme','user','pass','domain','port','path','query','fragment');$r='!(?:(\w+)://)?(?:(\w+)\:(\w+)@)?([^/:]+)?';$r.='(?:\:(\d*))?([^#?]+)?(?:\?([^#]+))?(?:#(.+$))?!i';preg_match_all($r,$url,$out);$return=array();foreach($element as$n=>$v){$return[$v]=$out[$n][0];}$return['rootdomain']=$return['subdomain']=$return['toplevelname']='';$return=empty($return['domain'])?$return:self::getDomain($return);$return['rootdomain']=empty($return['rootdomain'])?$return['domain']:$return['rootdomain'];return$return;}private static function getDomain($host){if(($total_parts=substr_count($host['domain'],'.'))<=1){return$host;}$parts_array=explode('.',$host['domain']);$last_part=$parts_array[$total_parts];$test_part=$parts_array[--$total_parts].'.'.$last_part;if(strpos(self::$top_names,$test_part.',')){$last_part=$parts_array[--$total_parts].'.'.$test_part;if(strpos(self::$top_names,$last_part.',')){$host['toplevelname']=$last_part;$last_part=$parts_array[--$total_parts].'.'.$last_part;$host['rootdomain']=$last_part;$host['subdomain']=str_ireplace('.'.$last_part,'',$host['domain']);}else{$host['rootdomain']=$last_part;$host['subdomain']=str_ireplace('.'.$last_part,'',$host['domain']);$host['toplevelname']=$test_part;}}else{$host['rootdomain']=$test_part;$host['subdomain']=str_ireplace('.'.$test_part,'',$host['domain']);$host['toplevelname']=$last_part;}return$host;}}namespace Nabble\SemaltBlocker;class Updater{public static$ttl=604800;public static$updateUrl='https://raw.githubusercontent.com/nabble/semalt-blocker/master/domains/blocked';private static$blocklist='blocked';public static function update($force=false){if(!defined('SEMALT_UNIT_TESTING')&&!self::isWritable())return;if(!$force&&!self::isOutdated())return;self::doUpdate();}public static function getNewDomainList(){if(function_exists('curl_init')){$curl=curl_init();curl_setopt_array($curl,array(CURLOPT_RETURNTRANSFER=>1,CURLOPT_URL=>self::$updateUrl));$domains=curl_exec($curl);curl_close($curl);}else{$domains=@file_get_contents(self::$updateUrl);}return$domains;}public static function getBlocklistFilename(){return __DIR__.DIRECTORY_SEPARATOR.static::$blocklist;}private static function doUpdate(){$domains=self::getNewDomainList();if(trim($domains)!=='')@file_put_contents(self::getBlocklistFilename(),$domains);}private static function isWritable(){return is_writable(self::getBlocklistFilename());}private static function isOutdated(){return filemtime(self::getBlocklistFilename())<(time()-self::$ttl);}}namespace Nabble\SemaltBlocker;class Blocker{const SEPERATOR=':';public static$explanation="Access to this website has been blocked because your referral is set to %s. <a href='%s'>Read why</a>";private static$blocklist='blocked';private static$debug='Not blocking, no reason given';public static function protect($action=''){if(!defined('SEMALT_UNIT_TESTING'))Updater::update();if(!self::isRefererOnBlocklist())return;self::doBlock($action);if(!defined('SEMALT_UNIT_TESTING'))exit;}public static function blocked($verbose=false){$blocked=self::isRefererOnBlocklist();if($verbose===true){return self::$debug;}return$blocked;}public function getReason(){return self::$debug;}public static function forbidden(){$protocol=(isset($_SERVER['SERVER_PROTOCOL'])?$_SERVER['SERVER_PROTOCOL']:'HTTP/1.0');header($protocol.' 403 Forbidden');}public static function isRefererOnBlocklist(){$referer=self::getHttpReferer();if($referer===null){self::$debug="Not blocking because referral header is not set or empty";return false;}$rootDomain=Domainparser::getRootDomain($referer);if($rootDomain===false){self::$debug="Not blocking because we couldn't parse referral domain";return false;}if(substr_count(self::getConcatenateBlocklist(),self::SEPERATOR.$rootDomain.self::SEPERATOR)===0){self::$debug="Not blocking because referral domain (".$rootDomain.") is not found on blocklist";return false;}self::$debug="Blocking because referral domain (".$rootDomain.") is found on blocklist";return true;}public static function getBlocklist(){return self::parseBlocklist(self::getBlocklistContents());}public static function getBlocklistFilename(){return __DIR__.DIRECTORY_SEPARATOR.static::$blocklist;}private static function doBlock($action=''){if(!defined('SEMALT_UNIT_TESTING'))self::cls();self::blockAction($action);echo sprintf(self::$explanation,self::getHttpReferer(),"https://www.google.com/#q=".urlencode(preg_replace('/https?:\/\//','',self::getHttpReferer())." referral spam"));}private static function blockAction($action=''){if(filter_var($action,FILTER_VALIDATE_URL)){self::redirect($action);}else{self::forbidden();if(!empty($action))echo$action.'<br/>';}}private static function cls(){while(ob_get_level())ob_end_clean();}private static function redirect($url){header("Location: ".$url);}private static function getHttpReferer(){if(isset($_SERVER['HTTP_REFERER'])&&!empty($_SERVER['HTTP_REFERER'])){return$_SERVER['HTTP_REFERER'];}return null;}private static function getBlocklistContents(){$blocklistContent=file_get_contents(self::getBlocklistFilename());return$blocklistContent;}private static function getConcatenateBlocklist(){return self::concatenateBlocklist(self::getBlocklistContents());}private static function parseBlocklist($blocklistContent){return array_map('trim',array_filter(explode(PHP_EOL,strtolower($blocklistContent))));}private static function concatenateBlocklist($blocklistContent){return self::SEPERATOR.str_replace(PHP_EOL,self::SEPERATOR,strtolower($blocklistContent)).self::SEPERATOR;}}